# Genesis Configuration - Choose ONE method only
# Method 1: Generate accounts and create genesis automatically. Genesis template is stored in the configmap
# Method 2: Download genesis from existing URL
# NOTE: Both methods cannot be used simultaneously - validation will fail if both are configured
genesis:
  # Method 1: Account Generation (generates new accounts and creates genesis with them)
  accountGeneration:
    enabled: false  # Set to true to enable automatic account generation
    count: 5        # Number of accounts to generate and fund in genesis. These accounts will be added under alloc{}
    password: "randompassword"  # Password for generated account keystores
    timestamp: 0x198c3a13dc8  # Timestamp for genesis block in milliseconds
  
  # Method 2: URL Download (downloads existing genesis file)
  url: "http://example.com/genesis.json"  # Set this to download genesis from URL


erigon:
  networkId: 10025
  datadir: "/data/erigon"
  ports:
    http: 8545
    ws: 8546
    authrpc: 8551
    metrics: 6061
    privateApi: 9095
  api:
    http:
      enabled: true
      addr: "0.0.0.0"
      vhosts: "*"
      corsdomain: "*"
      api: "eth,erigon,engine,net,web3,txpool"
    ws:
      enabled: true
      addr: "0.0.0.0"
      vhosts: "*"
    metrics:
      enabled: true
      addr: "0.0.0.0"
  zeroFeeTxList:
    - "0x0000000000000000000000000000000000000000"  # Contracts Deployer Keystore
    - "0x0000000000000000000000000000000000000000"  # Orcale Keystore
    #- "0x0000000000000000000000000000000000000000"  # Bridge Relayer Keystore
  pruneMode: "archive"
  nodiscover: true
  # Additional arguments to pass to erigon
  extraArgs: []
  # Example:
  # extraArgs:
  #   - "--trace.config=/path/to/trace.json"
  #   - "--state.scheme=path"

snode:
  instanceId: "snode1"
  priorityFeeRecipient: "0x0000000000000000000000000000000000000000"
  ports:
    api: 9090
    health: 8080
  logLevel: "info"
  # Additional arguments to pass to snode
  extraArgs: []
  # Example:
  # extraArgs:
  #   - "--metrics-enabled"


jwt:
  token: ""


image:
  erigon:
    repository:
    tag:
    pullPolicy: IfNotPresent
  snode:
    repository:
    tag:
    pullPolicy: IfNotPresent

storage:
  size: 100Gi
  storageClassName: premium-rwo
  accessMode: ReadWriteOnce

security:
  runAsUser: 0
  runAsGroup: 0
  runAsNonRoot: false
  fsGroup: 0

replicaCount: 1
terminationGracePeriodSeconds: 60

# Resource requests and limits
resources:
  erigon:
    requests:
      cpu: "1000m"
      memory: "2Gi"
    limits:
      cpu: "6000m"
      memory: "16Gi"
  snode:
    requests:
      cpu: "100m"
      memory: "1Gi"
    limits:
      cpu: "6000m"
      memory: "16Gi"

# Init container resources
initContainerResources:
  requests:
    cpu: "500m"
    memory: "500Mi"
  limits:
    cpu: "1000m"
    memory: "1Gi"

service:
  erigon:
    type: LoadBalancer
    ports:
      http: 8545
      ws: 8546
      authrpc: 8551
      metrics: 6061
    # Custom selector for erigon service - if provided, overrides default selector
    customSelector: {}
    # Example:
    # customSelector:
    #   app: erigon
    #   version: v1.0.0
  snode:
    type: ClusterIP
    ports:
      api: 9090
      health: 8080
    # Custom selector for snode service - if provided, overrides default selector  
    customSelector: {}
    # Example:
    # customSelector:
    #   app: snode
    #   component: consensus-layer

#nodeSelector:
#   workload-type: erigon


tolerations: []


affinity: {}


topologySpreadConstraints: []

# Additional labels for StatefulSet
additionalLabels: {}
# Example:
# additionalLabels:
#   environment: production
#   team: blockchain
#   version: v1.0.0

ingress:
  enabled: false
  className: "nginx"
  
  # RPC Configuration
  rpc:
    host: rpc.devnet.xyz
    path: /
    pathType: Prefix
    annotations:
      nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
      nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
      nginx.ingress.kubernetes.io/proxy-body-size: "0"
      nginx.ingress.kubernetes.io/proxy-read-timeout: "1200"
      nginx.ingress.kubernetes.io/proxy-send-timeout: "1200"
      nginx.ingress.kubernetes.io/ssl-redirect: "true"
  
  # WebSocket Configuration  
  websocket:
    host: ws.devnet.xyz
    path: /
    pathType: Prefix
    annotations:
      nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
      nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
      nginx.ingress.kubernetes.io/proxy-body-size: "0"
      nginx.ingress.kubernetes.io/proxy-read-timeout: "36h00"
      nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
      nginx.ingress.kubernetes.io/ssl-redirect: "true"
      # WebSocket specific annotations
      nginx.ingress.kubernetes.io/proxy-http-version: "1.1"
      nginx.ingress.kubernetes.io/proxy-set-headers: |
        Connection "upgrade"
        Upgrade $http_upgrade
  
  # TLS Configuration (shared)
  tls:
    secretName: devnet-tls # Should be pre-created if you using tls

