- name: Deploy Cluster
  hosts: nomad_clients
  gather_facts: yes

  vars:
    root_dir: "{{ playbook_dir }}/../../../"
    dist_dir: "/tmp/dist"
    release: false
    build_artifacts: false
    build_templates: false
    aws_s3_bucket: "primev-infrastructure-artifacts"

  pre_tasks:
    - name: Determine the Architecture of the Target System
      ansible.builtin.set_fact:
        target_system_architecture: "{{ 'arm64' if ansible_architecture == 'aarch64' else ansible_architecture }}"

    - name: Check Operating System of the Target System
      assert:
        that:
          - ansible_facts['os_family'] == "Debian"
        fail_msg: "This playbook only supports Debian systems."
        success_msg: "Operating system is supported."

    - name: Include Common Variables
      include_vars:
        file: variables/common.yml

    - name: Load AWS Caller Information
      amazon.aws.aws_caller_info:
      register: aws_caller_info
      delegate_to: localhost
      run_once: true
      become: true
      become_user: "{{ lookup('env', 'USER') }}"
      when: version is not defined or version == ''

    - name: Check AWS Caller Information
      ansible.builtin.assert:
        that:
          - aws_caller_info is defined
          - aws_caller_info.user_id is defined
          - aws_caller_info.user_id | length > 0
        fail_msg: "AWS caller information is invalid or empty."
        success_msg: "AWS caller information is valid."
      when: version is not defined or version == ''

    - name: Load Vault Initialization File
      slurp:
        src: "{{ vault_init_file }}"
      register: vault_init
      become: true
      become_user: "{{ ansible_user }}"

    - name: Parse Vault Initialization File
      ansible.builtin.set_fact:
        vault_init: "{{ vault_init | combine({'json': (vault_init['content'] | b64decode | from_json) }) }}"

    - name: Determine Artifacts Build Version
      ansible.builtin.shell: |
        if [ "{{ release | lower }}" = "false" ]; then
          echo "$(git rev-parse --short HEAD)$(git diff --quiet && echo '-'$(date +%s) || echo '-dirty-'$(date +%s))"
          exit 0
        fi

        if [ -n "$(git status --porcelain)" ]; then
          echo "Uncommitted changes detected."
          exit 1
        fi

        VERSION="$(git describe --tags --exact-match 2>/dev/null)"
        if [ -z "${VERSION}" ]; then
          echo "Failed to get version tag."
          exit 1
        fi
        echo "${VERSION}"
      args:
        executable: bash
      register: artifacts_build_version
      delegate_to: localhost
      run_once: true
      changed_when: false
      when: version is not defined or version == '' or release

    - name: Set Artifacts Build Version
      set_fact:
        build_artifacts: true
        version: "{{ artifacts_build_version.stdout }}"
      when: version is not defined or version == '' or release

    - name: Check Version
      ansible.builtin.assert:
        that:
          - version is defined
          - version | length > 0
        fail_msg: "The version is not set correctly."
        success_msg: "The version is set to: {{ version }}."

    - name: Include Environment Definitions
      include_vars:
        file: variables/environments.yml

    - name: Check Environment Name
      ansible.builtin.assert:
        that:
          - env is defined
          - env | length > 0
          - env in environments
        fail_msg: "The environment name is not set correctly."
        success_msg: "The environment name is set to: {{ env }}."

    - name: Include Profile Definitions
      include_vars:
        file: variables/profiles.yml

    - name: Check Profile Name
      ansible.builtin.assert:
        that:
          - profile is defined
          - profile | length > 0
          - profile in profiles
        fail_msg: "The profile name is not set correctly."
        success_msg: "The profile name is set to: {{ profile }}."

    - name: Determine Logs Collection
      set_fact:
        jobs: >-
          {{
            profiles[profile].jobs
            | selectattr('name', 'ne', 'datadog-agent-logs-collector')
            | list
            if no_logs_collection | default(false) | bool
            else profiles[profile].jobs
           }}

    - name: Determine "{{ ansible_env.HOME }}/{{ env }}" Status
      ansible.builtin.stat:
        path: "{{ ansible_env.HOME }}/{{ env }}"
      register: env_dir

    - name: Check "{{ ansible_env.HOME }}/{{ env }}" Directory Exists
      assert:
        that:
          - env_dir.stat.isdir is defined
          - env_dir.stat.isdir
        fail_msg: "The directory {{ ansible_env.HOME }}/{{ env }} does not exist."
        success_msg: "The directory {{ ansible_env.HOME }}/{{ env }} exists."

    - name: Read Existing "meta.json"
      ansible.builtin.shell: |
        cat "{{ ansible_env.HOME }}/{{ env }}/meta.json" 2>/dev/null || true
      register: existing_environment

    - name: Set Existing Scripts Artifact Version as Stale
      set_fact:
        build_templates: >-
          {{
            (existing_environment.stdout | from_json) != environments[env]
            if existing_environment.stdout | trim
            else true
          }}

    - name: Pre Deployment Info
      ansible.builtin.debug:
        msg: |
          Environment:     {{ env }}
          Chain ID:        {{ environments[env].chain_id }}
          Profile:         {{ environments[env].profile }}
          Version:         {{ environments[env].version }}
          Secrets:         {{ environments[env].secrets }}
          Hostname:        {{ ansible_hostname }}
          Build Artifacts: {{ 'yes' if build_artifacts | default(false) else 'no' }}
          Build Templates: {{ 'yes' if build_templates | default(false) else 'no' }}

  tasks:
    - name: Build keystore-generator
      ansible.builtin.shell: |
        BINARY_PATH="{{ dist_dir }}/keystore-generator-{{ environments[env].version }}"
        go build -o "${BINARY_PATH}" ./infrastructure/tools/keystore-generator/cmd/main.go
        echo "${BINARY_PATH}"
      args:
        chdir: "{{ root_dir }}"
        executable: bash
      delegate_to: localhost
      run_once: true
      register: keystore_generator
      when: build_artifacts

    - name: Build Artifacts Async
      ansible.builtin.shell: |
        SIGNERS="{{ dist_dir }}/signers.txt"
        SECRETS="{{ dist_dir }}/secrets.json"
        INVENTORY="{{ dist_dir }}/artifacts.txt"
        ALLOCATIONS="{{ dist_dir }}/allocations.txt"
        DESTINATION_DIR="{{ dist_dir }}/{{ item.name }}" && mkdir -p ${DESTINATION_DIR}
    
        [ ! -f "${SIGNERS}" ] && touch "${SIGNERS}"
        [ ! -f "${SECRETS}" ] && echo '{"version":"{{ environments[env].version }}"}' > "${SECRETS}"
        [ ! -f "${INVENTORY}" ] && touch "${INVENTORY}"
        [ ! -f "${ALLOCATIONS}" ] && touch "${ALLOCATIONS}"

        exec 190>>"${SIGNERS}"
        exec 191<>"${SECRETS}"
        exec 192<>"${INVENTORY}"
        exec 193>>"${ALLOCATIONS}"

        {% for artifact in item.artifacts | default([]) %}

          {% if artifact.type is defined and artifact.type == 'binary' %}
            flock -v -x 192
            if ! grep -qxF "{{ artifact.path }}" "${INVENTORY}"; then
              echo "{{ artifact.path }}" >> "${INVENTORY}"
              flock -v -u 192
              set -x
              cp ./{{ artifact.path }}/.goreleaser.yml ./{{ artifact.path }}/.goreleaser.tmp.yml
              if [ -n "${ARTIFACTS_GOOS}" ]; then
                yq eval -i ".builds[0].goos = [\"${ARTIFACTS_GOOS}\"]" ./{{ artifact.path }}/.goreleaser.tmp.yml
              fi
              if [ -n "${ARTIFACTS_GOARCH}" ]; then
                yq eval -i ".builds[0].goarch = [\"${ARTIFACTS_GOARCH}\"]" ./{{ artifact.path }}/.goreleaser.tmp.yml
              fi
              set +x
              goreleaser release --snapshot --config=./{{ artifact.path }}/.goreleaser.tmp.yml
              if [ $? -ne 0 ]; then exit 1; fi
              rm ./{{ artifact.path }}/.goreleaser.tmp.yml
            fi
            flock -v -u 192
          {% elif artifact.type is defined and artifact.type == 'archive' %}
            ARTIFACT="${DESTINATION_DIR}/{{ artifact.name | default(item.name) }}_{{ environments[env].version }}.tar.gz"
            if [ ! -f "${ARTIFACT}" ]; then
              flock -v -x 192
              echo "${ARTIFACT}" >> "${INVENTORY}"
              flock -v -u 192
              tar -czvf "${ARTIFACT}" ./{{ artifact.path }}
              if [ $? -ne 0 ]; then exit 1; fi
            fi
          {% endif %}

          {% if artifact.keystore is defined %}
            case "{{ environments[env].secrets }}" in
              "generate")
                PASSPHRASE="{{ lookup('password', '/dev/null', length=1024, chars=['ascii_letters', 'digits']) }}"

                RESULT=$(
                  {{ keystore_generator.stdout }} generate \
                    --keystore-dir="${DESTINATION_DIR}" \
                    --passphrase="${PASSPHRASE}" \
                    --log-fmt="json"
                )
                if [ $? -ne 0 ]; then exit 1; fi
                ARTIFACT_PATH="$(echo ${RESULT} | jq -e -r '.path // empty' 2>/dev/null)"
                flock -v -x 192
                echo "${ARTIFACT_PATH}" >> "${INVENTORY}"
                flock -v -u 192

                flock -v -x 191
                cat "${SECRETS}" | jq \
                  --arg keystore "$(cat ${ARTIFACT_PATH} | jq -c .)" \
                  --arg keystore_filename "$(basename ${ARTIFACT_PATH})" \
                  --arg keystore_password "${PASSPHRASE}" \
                  '. + {
                    "{{ artifact.keystore.name }}": $keystore,
                    "{{ artifact.keystore.name }}_filename": $keystore_filename,
                    "{{ artifact.keystore.name }}_password": $keystore_password
                  }' \
                > "${SECRETS}"
                if [ $? -ne 0 ]; then exit 1; fi
                flock -v -u 191

                ADDRESS="$(cat ${ARTIFACT_PATH} | jq -r '.address')"
                {% if artifact.keystore.allocation | default(false) %}
                  flock -v -x 193
                  echo "${ADDRESS}" >> "${ALLOCATIONS}"
                  flock -v -u 193
                {% endif %}
                {% if item.env is defined and item.env.type | default('') == 'signer' %}
                  flock -v -x 190
                  echo "${ADDRESS}" >> "${SIGNERS}"
                  flock -v -u 190
                {% endif %}
                ;;
              "fetch")
                RESPONSE=$(curl \
                  --silent \
                  --insecure \
                  --header "X-Vault-Token: {{ vault_init.json.root_token }}" \
                  {{ vault_address }}/v1/{{ vault_kv_engine_path }}/data/{{ vault_secret_path }}
                )
                if [ -z "${RESPONSE}" ]; then
                  echo "Error: No secrets found."
                  exit 1
                fi

                KEYSTORE=$(echo "${RESPONSE}" | jq -r '.data.data.{{ artifact.keystore.name }}')
                if [ -z "${KEYSTORE}" ]; then
                  echo "Error: No keystore found for {{ artifact.keystore.name }}."
                  exit 1
                fi
                PASSPHRASE=$(echo "${RESPONSE}" | jq -r '.data.data.{{ artifact.keystore.name }}_password')
                if [ -z "${PASSPHRASE}" ]; then
                  echo "Error: No passphrase found for {{ artifact.keystore.name }}."
                  exit 1
                fi

                flock -v -x 191
                cat "${SECRETS}" | jq \
                  --arg keystore "$(echo $KEYSTORE | jq -c .)" \
                  --arg keystore_filename "$(basename ${KEYSTORE})" \
                  --arg keystore_password "${PASSPHRASE}" \
                  '. + {
                    "{{ artifact.keystore.name }}": $keystore,
                    "{{ artifact.keystore.name }}_filename": $keystore_filename,
                    "{{ artifact.keystore.name }}_password": $keystore_password
                  }' \
                > "${SECRETS}"
                if [ $? -ne 0 ]; then exit 1; fi
                flock -v -u 191

                ADDRESS=$(echo "${KEYSTORE}" | jq -r '.address')
                {% if artifact.keystore.allocation | default(false) %}
                  flock -v -x 193
                  echo "${ADDRESS}" >> "${ALLOCATIONS}"
                  flock -v -u 193
                {% endif %}
                {% if item.env is defined and item.env.type | default('') == 'signer' %}
                  flock -v -x 190
                  echo "${ADDRESS}" >> "${SIGNERS}"
                  flock -v -u 190
                {% endif %}
                ;;
              *)
                echo "Error: Unknown secrets type: {{ environments[env].secrets }}."
                exit 1
                ;;
            esac
          {% endif %}
          {% if artifact.boot_key | default(false) and environments[env].secrets == 'generate' %}
            bootnode -genkey "${DESTINATION_DIR}/boot.key"
            if [ $? -ne 0 ]; then exit 1; fi

            flock -v -x 191
            cat "${SECRETS}" | jq \
              --arg item_name "{{ (item.name | regex_replace('^mev-commit-', '') | replace('-', '_')) }}" \
              --arg boot_key "$(cat ${DESTINATION_DIR}/boot.key)" \
              --arg boot_key_address "$(bootnode -nodekey ${DESTINATION_DIR}/boot.key -writeaddress)" \
              '. + {
                ($item_name + "_boot_key"): $boot_key,
                ($item_name + "_boot_key_address"): $boot_key_address
              }' \
            > "${SECRETS}"
            if [ $? -ne 0 ]; then exit 1; fi
            flock -v -u 191

          {% endif %}
        {% endfor %}

        exec 190>&-
        exec 191>&-
        exec 192>&-
        exec 193>&-
      environment:
        ARTIFACTS_GOOS: "{{ lookup('env', 'ARTIFACTS_GOOS') }}"
        ARTIFACTS_GOARCH: "{{ lookup('env', 'ARTIFACTS_GOARCH') }}"
        DIRTY_SUFFIX: "{{ environments[env].version | regex_search('-.*') | default('') }}"
        RELEASE_VERSION: "{{ environments[env].version if release else '' }}"
      args:
        chdir: "{{ root_dir }}"
        executable: bash
      loop: "{{ jobs }}"
      loop_control:
        label: "{{ item.name }}"
      async: 600
      poll: 0
      delegate_to: localhost
      run_once: true
      register: build_artifacts_async
      when: build_artifacts

    - name: Wait for Build Artifacts Async to Complete
      ansible.builtin.async_status:
        jid: "{{ item.ansible_job_id }}"
      register: build_artifacts_async_result
      until: build_artifacts_async_result.finished
      retries: 200
      delay: 3
      loop: "{{ build_artifacts_async.results }}"
      loop_control:
        label: "{{ item.item.name }}"
      delegate_to: localhost
      run_once: true
      when: build_artifacts

    - name: Assemble Genesis File
      ansible.builtin.shell: |
        ALLOCATIONS="$(cat {{ dist_dir }}/allocations.txt 2>/dev/null)"
        SIGNERS="$(cat {{ dist_dir }}/signers.txt 2>/dev/null)"
        if [ -z "${SIGNERS}" ]; then
          echo "Error: No signers found."
          exit 1
        fi

        ALLOC=$(echo '{}' | jq '.')
        for ADDRESS in ${ALLOCATIONS}; do
          ALLOC=$(
            echo "${ALLOC}" | jq --arg address "0x${ADDRESS}" '
              . + {
                ($address): {
                    "balance": "0x10000000000000000000000000000"
                }
              }
            '
         )
        done

        ADDRESS_COUNT=0
        EXTRADATA="0x$(printf '0%.0s' {1..64})"
        for ADDRESS in ${SIGNERS}; do
          if [ ${ADDRESS_COUNT} -lt 3 ]; then
            ADDRESS_COUNT=$((ADDRESS_COUNT + 1))
            EXTRADATA+=${ADDRESS}
          else
            echo "Error: Maximum number of signers (3) reached."
          fi
        done
        EXTRADATA+="$(printf '0%.0s' {1..130})"

        echo $(cat <<-EOH
        {
          "config": {
            "chainId": {{ environments[env].chain_id }},
            "homesteadBlock": 0,
            "eip150Block": 0,
            "eip155Block": 0,
            "eip158Block": 0,
            "byzantiumBlock": 0,
            "constantinopleBlock": 0,
            "petersburgBlock": 0,
            "istanbulBlock": 0,
            "muirGlacierBlock": 0,
            "berlinBlock": 0,
            "londonBlock": 0,
            "arrowGlacierBlock": 0,
            "grayGlacierBlock": 0,
            "clique": {
              "period": 200,
              "epoch": 30000
            }
          },
          "nonce": "0x0",
          {% if environments[env].genesis_timestamp is defined %}
          "timestamp": "{{ environments[env].genesis_timestamp }}",
          {% else %}
          "timestamp": "0x$(printf "%x" "$(date +%s)")",
          {% endif %}
          "difficulty": "0x1",
          "gasLimit": "0x1c9c380",
          "coinbase": "0x0000000000000000000000000000000000000000",
          "mixHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
          "alloc": ${ALLOC},
          "extradata": "${EXTRADATA}"
        }
        EOH
        ) | jq -c '.' > "{{ dist_dir }}/genesis_{{ environments[env].version }}.json"
      args:
        executable: bash
      register: genesis_facts
      delegate_to: localhost
      run_once: true
      when: build_artifacts

    - name: Filter Artifacts for Upload
      ansible.builtin.find:
        paths: "{{ dist_dir }}"
        patterns: >-
          [
          "*{{ environments[env].version }}*.*"
          {% if env == 'devenv' %},
          "secrets.json"
          {% endif %}
          ]
        recurse: yes
      register: upload_artifacts
      delegate_to: localhost
      run_once: true
      when: build_artifacts

    - name: Upload Artifacts Async to AWS S3
      amazon.aws.aws_s3:
        bucket: "{{ aws_s3_bucket }}"
        object: "{{ item.path | basename }}"
        src: "{{ item.path }}"
        mode: put
      loop: "{{ upload_artifacts.files }}"
      loop_control:
        label: "{{ item.path | basename }}"
      async: 1000
      poll: 0
      delegate_to: localhost
      run_once: true
      register: upload_artifacts_async
      when: build_artifacts and upload_artifacts.matched > 0 and env != 'devenv'

    - name: Wait for Upload Artifacts Async to Complete
      ansible.builtin.async_status:
        jid: "{{ item.ansible_job_id }}"
      register: upload_artifacts_async_result
      until: upload_artifacts_async_result.finished
      retries: 600
      delay: 1
      loop: "{{ upload_artifacts_async.results }}"
      loop_control:
        label: "{{ item.item.path | basename }}"
      delegate_to: localhost
      run_once: true
      when: build_artifacts and upload_artifacts.matched > 0 and env != 'devenv'

    - name: Ensure Target Directory Exists and is Empty
      ansible.builtin.shell: |
        rm -rf {{ ansible_env.HOME }}/{{ env }}/artifacts/ && mkdir {{ ansible_env.HOME }}/{{ env }}/artifacts/
      args:
        executable: bash
      when: build_artifacts and upload_artifacts.matched > 0 and env == 'devenv'

    - name: Copy Artifacts to Target Machine
      ansible.builtin.copy:
        src: "{{ item.path }}"
        dest: "{{ ansible_env.HOME }}/{{ env }}/artifacts/{{ item.path | basename }}"
      loop: "{{ upload_artifacts.files }}"
      loop_control:
        label: "{{ item.path | basename }}"
      when: build_artifacts and upload_artifacts.matched > 0 and env == 'devenv'

    - name: Read Generated Secrets
      slurp:
        src: "{{ dist_dir }}/secrets.json"
      register: secrets_json
      when: build_artifacts and environments[env].secrets == 'generate'
      delegate_to: localhost
      run_once: true

    - name: Debug Generated Secrets
      ansible.builtin.debug:
        msg: "{{ secrets_json.content | b64decode }}"
      when: build_artifacts and env == 'devenv' and environments[env].secrets == 'generate'
      delegate_to: localhost
      run_once: true

    - name: Push Generated Secrets to Vault
      ansible.builtin.uri:
        url: "{{ vault_address }}/v1/{{ vault_kv_engine_path }}/data/{{ vault_secret_path }}"
        method: POST
        body_format: json
        headers:
          X-Vault-Token: "{{ vault_init.json.root_token }}"
          Content-Type: "application/json"
        body: "{{ {'data': (secrets_json.content | b64decode | from_json)} | to_json }}"
        status_code: [200, 204]
        validate_certs: no
      when: build_artifacts and environments[env].secrets == 'generate'
      delegate_to: localhost

    - name: Cleanup Built Artifacts
      ansible.builtin.file:
        path: "{{ dist_dir }}"
        state: absent
      delegate_to: localhost
      run_once: true
      when: build_artifacts and upload_artifacts.matched > 0

    - name: Delete "meta.json"
      file:
        path: "{{ ansible_env.HOME }}/{{ env }}/meta.json"
        state: absent
      when: build_templates

    - name: Build Templates
      ansible.builtin.template:
        src: "templates/jobs/{{ item.template }}"
        dest: "{{ ansible_env.HOME }}/{{ env }}/{{ item.name }}.nomad"
      loop: "{{ jobs }}"
      loop_control:
        label: "{{ item.name }}"
      vars:
        job: "{{ item }}"
      when: build_templates

    - name: Create "meta.json"
      ansible.builtin.shell: |
        echo '{{ environments[env] | to_json }}' > {{ ansible_env.HOME }}/{{ env }}/meta.json
        ln -f {{ ansible_env.HOME }}/{{ env }}/meta.json {{ ansible_env.HOME }}/{{ env }}/artifacts/meta.json
      when: build_templates

    - name: Purge Cluster
      ansible.builtin.shell: |
        nomad var purge "nomad/jobs"
        nomad system gc
      args:
        executable: bash

    - name: Deploy Jobs
      ansible.builtin.shell: |
        nomad run {{ ansible_env.HOME }}/{{ env }}/{{ job.name }}.nomad

        TIMEOUT={% if profile == 'ci' %}600{% else %}300{% endif %}
        START_TIME=$(date +%s)
        RESULT=$(nomad job status -json "{{ job.name }}")
        if [ $? -ne 0 ]; then
          echo "Failed to get job status for {{ job.name }}:"
          echo "${RESULT}"
          exit 1
        fi
        JOB_TYPE=$(echo "${RESULT}" | jq -r '.[0].Allocations[0].JobType')

        while true; do
          STATUS=$(echo "${RESULT}"  | jq -r '.[0].Allocations[0].ClientStatus')

          case "${JOB_TYPE}" in
            service)
              if [ "${STATUS}" = "running" ]; then
                break
              fi
              ;;
            batch)
              if [ "${STATUS}" = "complete" ]; then
                break
              fi
              ;;
            *)
              {% if env != 'devenv' %}
              break
              {% else %}
              echo "Unknown job type: ${JOB_TYPE}"
              exit 1
              {% endif %}
              ;;
          esac

          CURRENT_TIME="$(date +%s)"
          ELAPSED_TIME="$(( CURRENT_TIME - START_TIME ))"
          if [ ${ELAPSED_TIME} -ge ${TIMEOUT} ]; then
            echo "Deploy timed out for {{ job.name }}, current status: ${STATUS}"
            exit 1
          fi

          sleep 1
          RESULT=$(nomad job status -json "{{ job.name }}")
          if [ $? -ne 0 ]; then
            echo "Failed to get job status for {{ job.name }}:"
            echo "${RESULT}"
            exit 1
          fi
        done
      args:
        executable: bash
      loop: "{{ jobs }}"
      loop_control:
        label: "{{ item.name }}"
      vars:
        job: "{{ item }}"
      register: result
      failed_when: result.rc != 0

    - name: Post Deployment Info
      ansible.builtin.debug:
        msg: |
          Environment: {{ env }}
          Chain ID:    {{ environments[env].chain_id }}
          Profile:     {{ environments[env].profile }}
          Version:     {{ environments[env].version }}
          Secrets:     {{ {'generate': 'generated', 'fetch': 'fetched'}.get(environments[env].secrets, 'unknown') }}
          Artifacts:   {{ 'built' if build_artifacts | default(false) else 'skipped' }}
          Templates:   {{ 'built' if build_templates | default(false) else 'skipped' }}
          Timestamp:   {{ now(utc=true, fmt='%a %Y-%m-%d %H:%M:%S UTC') }}
          Hostname:    {{ ansible_hostname }}
